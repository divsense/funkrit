{ Node, ImportDeclaration, ImportSpecifier, Identifier } <: "./ast-types"
{ Result_Monad } <: './result' 

{ requiredIdentifiers } <+ './required-identifiers'
{ import2require, export2require } <+ './commonjs'
{ parse } <+ './peg-parser' 
{ Result } <+ './result'

StdLib := {
    source: string,
    names: string[]
}

Settings := {
    code: string,
    stdLib: StdLib,
    commonJs: boolean
}

build :: Settings -> Result_Monad<?Node>
build = {code, commonJs, stdLib} -> {

    process =  when(always(commonJs), export2require . import2require)
               . over(@body, reduce(removeEmptyImports, []))
               . selectUsedNames
               . addFunkritFullUse(stdLib)
               . parse

    return process <^> Result(code)

}

removeEmptyImports :: (Node[], Node) -> Node[]
removeEmptyImports = (body, node) -> {
    if((node <.> type) !== 'ImportDeclaration' || length(node <.> specifiers) > 0) {
        return append(node, body)
    } else {
        return body
    }
}

importSpec :: string -> ImportSpecifier
importSpec = name -> ({
    type: 'ImportSpecifier',
    imported: {
        type: 'Identifier',
        name
    },
    local: {
        type: 'Identifier',
        name
    }
})

makeFunkritFullUse :: StdLib -> ImportDeclaration
makeFunkritFullUse = {source, names} -> ({
  type: 'ImportDeclaration',
  source: {
    type: 'Literal',
    value: source
  },
  specifiers: importSpec <^> names,
  funkrit: { use: 'Full' }
})

addFunkritFullUse :: StdLib -> Node -> Node
addFunkritFullUse = stdlib -> over(@body, prepend $ makeFunkritFullUse $ stdlib)

extractUsedNames :: string[] -> (ImportSpecifier[], ImportSpecifier) -> ImportSpecifier[]
extractUsedNames = names -> (m, spec) -> indexOf(path(['local', 'name'], spec), names) === -1 ? m : append(spec, m)

usedNames :: string[] -> Node -> Node
usedNames = names -> node -> ((node <.> type) === 'ImportDeclaration' && pathEq(['funkrit', 'use'], 'Full', node))
        ? over(@specifiers, reduce(extractUsedNames(names), []), node) : node

selectUsedNames :: Node -> Node
selectUsedNames = ast -> {
    names = requiredIdentifiers(ast)
    return over(@body, map(usedNames(names)), ast)
}


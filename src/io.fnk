Effect<A> := () -> A | Function

IO_Monad<A> := {
    run: Effect<A>,
    pure(A): IO_Monad<A>,
    map<B>((A) -> B): IO_Monad<B>,
    chain<B>((A) -> IO_Monad<B>): IO_Monad<B>,
    ap<B>(IO_Monad<B>): IO_Monad<B>
}

IO<A> :: Effect<A> -> IO_Monad<A>
IO = run -> ({
    run,

    pure :: A -> IO_Monad<A>
    pure: a -> IO $ () -> a,

    map<B> :: (A -> B) -> IO_Monad<B>
    map: f -> IO $ f . run,

    chain<B> :: (A -> IO_Monad<B>) -> IO_Monad<B>
    chain: f -> IO $ runIO . f . run,

    ap<B> :: IO_Monad<B> -> IO_Monad<B>
    ap: mv -> IO $ () -> runIO $ apIO(run(), mv)
})

apIO<A,B> :: (Function, IO_Monad<A>) -> IO_Monad<B>
apIO = (f, mb) -> map(f, mb)

pureIO<A> :: A -> IO_Monad<A>
pureIO = a -> IO $ () -> a

runIO<A> :: IO_Monad<A> -> A
runIO = x -> (call . prop('run'))(x)


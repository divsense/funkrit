export Reader, pureReader, ask, ReaderT, askT

Reader :: (r -> a) -> Reader a
Reader = run -> ({
    run,

    // map :: Reader a ~> (a -> b) -> Reader b
    map: f -> Reader $ f . run,

    // chain :: Reader a ~> (a -> Reader b) -> Reader b
    chain: f -> Reader $ converge(call, [prop('run') . f . run, identity])

})

pureReader = a -> Reader $ r -> a
ask = () -> Reader $ identity

ReaderT :: (r -> m a) -> ReaderT m a
ReaderT = run -> ({

    run,

    // map :: (a -> b) -> ReaderT m b
    map: f -> ReaderT $ map(f) . run,

    // chain :: (a -> ReaderT m b) -> ReaderT m b
    chain: f -> ReaderT $ r -> run(r) >>= x -> prop('run', f(x)) $ r
})

askT :: (a -> m a) -> ReaderT m r
askT = m -> ReaderT $ m


export Right, Left, isRight, isLeft, right, left,
       EitherT, runEitherT, liftEitherT
use 'ramda'

checkForNil :: Either(x, y) -> Either(x, y)
checkForNil = when(isNil . prop('right'), always $ Left('null'))

checkForInfinity :: Either(x, y) -> Either(x, y)
checkForInfinity = when(propEq('right', Infinity), always $ Left('Infinity'))

checkForAbnormal :: Either(x, y) -> Either(x, y)
checkForAbnormal = unless(has('left'), checkForInfinity . checkForNil)

safeMap :: (a -> Either(x, b)) -> b -> Either(x, b)
safeMap = f -> checkForAbnormal . tryCatch(f, Left)

Right :: a -> Right(a)
Right = right -> ({
    right,

    run: () -> right,

    // map :: Right(a) ~> (a -> b) -> Either(x, b)
    map: f -> safeMap(Right . f) $ right,

    // chain :: Right(a) ~> (a -> Either(x, b)) -> Either(x, b)
    chain: f -> safeMap(f) $ right
})

Left :: a -> Left(a)
Left = left -> ({
    left,
    map: _ -> Left $ left,
    chain: _ -> Left $ left
})

isRight = has('right')
isLeft = has('left')
right = prop('right')
left = prop('left')

// EitherT
pureOf = m -> prop('pure', m)

safeBind :: m, (a -> m Either b) -> Right a -> m Either b
safeBind = (m, f) -> tryCatch(prop('monad') . f, pureOf(m) . Left) . right

EitherT :: m (Either a) -> EitherT m (Either a)
EitherT = monad -> ({
    monad,

    // map :: (a -> b) -> EitherT
    map: f -> EitherT $ map(map(f), monad),

    // chain :: (a -> EitherT) -> EitherT
    chain: f -> EitherT $ monad >>= ifElse(isLeft, pureOf(monad), safeBind(monad, f))
})

runEitherT :: EitherT m a -> a
runEitherT = call . prop('run') . prop('monad')

liftEitherT :: m a -> EitherT m a
liftEitherT = EitherT . map(Right)
/*
liftEitherT = m -> EitherT $ tryCatch(map(Right), err -> {
    console.log("*** ERR", err)
    return map(Left, pureOf(m) $ err)
}) $ m
*/

